# Spring Boot Redis 缓存示例

本项目演示了 Spring Boot 与 Redis 集成实现缓存功能，包括缓存穿透、缓存击穿、缓存雪崩等常见问题的解决方案。

## 功能特点

- 基于 Spring Cache 和 Redis 实现的缓存系统
- 演示缓存穿透、缓存击穿、缓存雪崩的解决方案
- 使用 @Cacheable、@CachePut、@CacheEvict 注解实现缓存操作
- 自定义缓存配置，包括序列化方式、过期时间等
- 提供缓存管理接口，支持清除缓存、查看缓存统计信息

## 缓存问题及解决方案

### 缓存穿透

**问题**：查询一个不存在的数据，缓存中没有，数据库中也没有，导致每次都会查询数据库。

**解决方案**：
- 缓存空值：当数据库查询不到数据时，仍然将空值标记缓存起来，但设置较短的过期时间
- 布隆过滤器：在查询缓存前，先通过布隆过滤器判断该 key 是否存在

### 缓存击穿

**问题**：热点数据过期的瞬间，大量请求同时访问该数据，导致所有请求都直接访问数据库。

**解决方案**：
- 互斥锁：使用分布式锁，保证同一时刻只有一个请求能够查询数据库并更新缓存
- 热点数据永不过期：对于热点数据，可以设置永不过期，而是通过后台线程定期更新缓存
- 双重检查：获取锁后再次检查缓存，避免重复查询数据库

### 缓存雪崩

**问题**：大量缓存同时过期或 Redis 服务宕机，导致大量请求直接访问数据库。

**解决方案**：
- 过期时间随机化：给缓存的过期时间增加随机值，避免同时过期
- 多级缓存：引入本地缓存作为二级缓存，当 Redis 宕机时仍能提供服务
- 服务熔断和降级：当系统负载过高时，启动熔断机制，返回默认值或错误提示

### 缓存与数据库双写一致性

**问题**：更新数据时，如何保证缓存和数据库的数据一致性。

**解决方案**：
- 先删缓存，再更新数据库，最后再次删除缓存（延迟双删）
- 先更新数据库，再删除缓存
- 使用消息队列，保证最终一致性
- 使用分布式事务

## API 接口

### 用户接口

- `POST /api/users` - 创建用户
- `GET /api/users/{id}` - 获取用户
- `GET /api/users/penetration/{id}` - 获取用户（演示缓存穿透）
- `GET /api/users/breakdown/{id}` - 获取用户（演示缓存击穿）
- `GET /api/users/avalanche/{id}` - 获取用户（演示缓存雪崩）
- `GET /api/users/consistency-demo` - 演示双写一致性
- `GET /api/users` - 获取所有用户
- `PUT /api/users/{id}` - 更新用户
- `DELETE /api/users/{id}` - 删除用户

### 缓存管理接口

- `DELETE /api/cache/{cacheName}` - 清除指定缓存
- `DELETE /api/cache` - 清除所有缓存
- `GET /api/cache/stats` - 获取缓存统计信息

## 运行项目

1. 确保已安装 Redis 并启动服务
2. 修改 `application.yml` 中的 Redis 配置
3. 运行 `RedisCacheApplication` 类启动应用
4. 访问 `http://localhost:8080/demo/` 测试接口

## 技术栈

- Spring Boot 2.7.x
- Spring Data Redis
- Spring Cache
- Lombok
- Jackson